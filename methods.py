from collections import defaultdict
from scipy.spatial import cKDTree
import numpy as np
import datetime
import operator
import geopy
import geopy.distance
import math

class GpsPoint:
	def __init__(self, vehicule_id=None, lon=None, lat=None, speed=None, timestamp=None, angle=None):
			self.vehicule_id = int(vehicule_id) if vehicule_id != None else 0
			self.speed = float(speed) if speed != None else 0.0
			if timestamp != None:
				self.timestamp = datetime.datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S+03')
			self.lon = float(lon)
			self.lat = float(lat)
			self.angle = float(angle)

	def get_coordinates(self):
		"""
		return the lon,lat of a gps point
		:return: tuple (lon, lat)
		"""
		return (self.lat, self.lon)

	def get_lonlat(self):
		return (self.lon, self.lat)

	def __str__(self):
		return "bt_id:%s, speed:%s, timestamp:%s, lon:%s, lat:%s, angle:%s" % \
			   (self.vehicule_id, self.speed, self.timestamp, self.lon, self.lat, self.angle)

	def __repr__(self):
		return "bt_id:%s, speed:%s, timestamp:%s, lon:%s, lat:%s, angle:%s" % \
			   (self.vehicule_id, self.speed, self.timestamp, self.lon, self.lat, self.angle)


def load_data(fname='data/gps_data/gps_points.csv'):
	"""
	Given a file that contains gps points, this method creates different data structures
	:param fname: the name of the input file, as generated by QMIC
	:return: data_points (list of gps positions with their metadata), raw_points (coordinates only),
	points_tree is the KDTree structure to enable searching the points space
	"""
	data_points = list()
	raw_points = list()

	with open(fname, 'r') as f:
		f.readline()
		for line in f:
			if len(line) < 10:
				continue
			vehicule_id, timestamp, lat, lon, speed, angle = line.split(',')
			pt = GpsPoint(vehicule_id=vehicule_id, timestamp=timestamp, lat=lat, lon=lon, speed=speed,angle=angle)
			data_points.append(pt)
			raw_points.append(pt.get_coordinates())
	print 'Len raw points:', len(raw_points)
	points_tree = cKDTree(raw_points)
	return np.array(data_points), np.array(raw_points), points_tree


def create_trajectories(INPUT_FILE_NAME='data/gps_data/gps_points_07-11.csv', waiting_threshold=5):
	"""
	return all trajectories.
	The heuristic is simple. Consider each users sorted traces not broken by more than 1 hour as trajectories.
	:param waiting_threshold: threshold for trajectory split expressed in seconds.
	:return: list of lists of trajectories
	"""

	data_points, raw_points, points_tree = load_data(fname=INPUT_FILE_NAME)
	detections = defaultdict(list)
	for p in data_points:
		detections[p.vehicule_id].append(p)

	# compute trajectories: split detections by waiting_threshold
	print 'Computing trajectories'
	trajectories = []
	for btd, ldetections in detections.iteritems():
		points = sorted(ldetections, key=operator.attrgetter('timestamp'))
		source = 0
		prev_point = 0
		i = 1
		while i < len(points):
			delta = points[i].timestamp - points[prev_point].timestamp
			if delta.days * 24 * 3600 + delta.seconds > waiting_threshold:
				trajectories.append(points[source: i])
				source = i
			prev_point = i
			i += 1
		if source < len(points):
			trajectories.append(points[source: -1])
	return trajectories


def diffangles(a1, a2):
	return 180 - abs(abs(a1 - a2) - 180)


def partition_edge(edge, distance_interval):
	"""
	given an edge, creates holes every x meters (distance_interval)
	:param edge: a given edge
	:param distance_interval: in meters
	:return: list of holes
	"""

	# We always return the source node of the edge, hopefully the target will be added as the source of another edge.
	holes = []
	d = geopy.distance.VincentyDistance(meters=distance_interval)
	# make sure we are using lat,lon not lon,lat as a reference.
	startpoint = geopy.Point(edge[0])
	endpoint = geopy.Point(edge[1])
	initial_dist = geopy.distance.distance(startpoint, endpoint).meters
	if initial_dist < distance_interval:
		# return [], distance_interval - initial_dist
		return holes
	# compute the angle=bearing at which we need to be moving.
	bearing = calculate_bearing(startpoint[0], startpoint[1], endpoint[0], endpoint[1])
	last_point = startpoint
	for i in range(int(initial_dist) / distance_interval):
		new_point = geopy.Point(d.destination(point=last_point, bearing=bearing))
		holes.append(GpsPoint(lat=new_point.latitude, lon=new_point.longitude, angle=bearing))
		last_point = new_point
	# return holes, initial_dist - (initial_dist / distance_interval) * distance_interval
	return holes

def calculate_bearing(latitude_1, longitude_1, latitude_2, longitude_2):
	"""
	Got it from this link: http://pastebin.com/JbhWKJ5m
   Calculation of direction between two geographical points
   """
	rlat1 = math.radians(latitude_1)
	rlat2 = math.radians(latitude_2)
	rlon1 = math.radians(longitude_1)
	rlon2 = math.radians(longitude_2)
	drlon = rlon2 - rlon1

	b = math.atan2(math.sin(drlon) * math.cos(rlat2), math.cos(rlat1) * math.sin(rlat2) -
	               math.sin(rlat1) * math.cos(rlat2) * math.cos(drlon))
	return (math.degrees(b) + 360) % 360
#
# def heading_vector_re_north(s, d):
# 	"""
# 	WRONG, doesn't account for the actual direction of the vector.!!!
# 	compute the vector angle from the north (north = 0 degree)
# 	:param s: source point
# 	:param d: destination point
# 	:return: angle in degrees from the north
# 	"""
# 	num = d.lat - s.lat
# 	den = d.lon - s.lon
# 	if den == 0 and num > 0:
# 		angle = 90
# 	elif den == 0 and num < 0:
# 		angle = -90
# 	else:
# 		angle = math.degrees(math.atan(num / den))
# 	return -1 * angle + 90

def vector_direction_re_north(s, d):
	"""
	Make the source as the reference of the plan. Then compute atan2 of the resulting destination point
	:param s: source point
	:param d: destination point
	:return: angle!
	"""

	# find the new coordinates of the destination point in a plan originated at source.
	new_d_lon = d.lon - s.lon
	new_d_lat = d.lat - s.lat
	 # angle = -angle + 90 is used to change the angle reference from east to north.
	angle = -math.degrees(math.atan2(new_d_lat, new_d_lon)) + 90

	# the following is required to move the degrees from -180, 180 to 0, 360
	if angle < 0:
		angle = angle + 360
	return angle