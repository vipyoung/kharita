from collections import defaultdict
from scipy.spatial import cKDTree
import numpy as np
import datetime
import operator
import geopy
import geopy.distance
import math
import networkx as nx
from matplotlib import pyplot as plt
from matplotlib import collections as mc


class GpsPoint:
	def __init__(self, vehicule_id=None, lon=None, lat=None, speed=None, timestamp=None, angle=None):
			self.vehicule_id = int(vehicule_id) if vehicule_id != None else 0
			self.speed = float(speed) if speed != None else 0.0
			self.timestamp = datetime.datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S+03') if timestamp !=None else 0
			self.lon = float(lon)
			self.lat = float(lat)
			self.angle = float(angle)

	def get_coordinates(self):
		"""
		return the lon,lat of a gps point
		:return: tuple (lon, lat)
		"""
		return (self.lat, self.lon)

	def get_lonlat(self):
		return (self.lon, self.lat)

	def __str__(self):
		return "bt_id:%s, speed:%s, timestamp:%s, lon:%s, lat:%s, angle:%s" % \
			   (self.vehicule_id, self.speed, self.timestamp, self.lon, self.lat, self.angle)

	def __repr__(self):
		return "bt_id:%s, speed:%s, timestamp:%s, lon:%s, lat:%s, angle:%s" % \
			   (self.vehicule_id, self.speed, self.timestamp, self.lon, self.lat, self.angle)


class Cluster:
	def __init__(self, cid=None, nb_points=None, last_seen=None, lat=None, lon=None, angle=None):
		self.cid = cid
		self.lon = lon
		self.lat = lat
		self.angle = angle
		self.last_seen = last_seen
		self.nb_points = nb_points
		self.points = []

	def get_coordinates(self):
		return (self.lat, self.lon)

	def get_lonlat(self):
		return (self.lon, self.lat)

	def add(self, point):
		self.points.append(point)
		self.nb_points += 1
		self.last_seen = point.timestamp
		#self._recompute_center()

	def _recompute_center(self):
		self.lon = sum([p.lon for p in self.points]) / len(self.points)
		self.lat = sum([p.lat for p in self.points]) / len(self.points)
		self.angle = self._meanangle([p.angle for p in self.points])

	def _meanangle(self, anglelist):
		"""
		Author: Rade Stanojevic.
		Computes the average value of a list of angles expressed in 0-360 interval.
		:param anglelist: list of angles
		:return: average
		"""
		return(np.arctan2(sum([np.sin(alpha/360*2*np.pi) for alpha in anglelist]),sum([np.cos(alpha/360*2*np.pi) for alpha in anglelist]))*180/np.pi)


def satisfy_path_condition_distance(s, t, g, clusters, alpha):
	"""
	return False if there's a path of length max length, True otherwise
	:param s:
	:param t:
	:param k_reach:
	:return:
	"""
	if s == -1 or t == -1 or s == t:
		return False

	edge_distance = geopy.distance.distance(geopy.Point(clusters[s].get_coordinates()), \
	                                        geopy.Point(clusters[t].get_coordinates())).meters
	if not nx.has_path(g, s, t):
		return True
	path = nx.shortest_path(g, source=s, target=t)
	path_length_meters = 0
	for i in range(1, len(path)):
		path_length_meters += geopy.distance.distance(geopy.Point(clusters[path[i - 1]].get_coordinates()),\
	                                        geopy.Point(clusters[path[i]].get_coordinates())).meters
	if path_length_meters >= alpha * edge_distance:
		return True
	return False


def load_data(fname='data/gps_data/gps_points.csv'):
	"""
	Given a file that contains gps points, this method creates different data structures
	:param fname: the name of the input file, as generated by QMIC
	:return: data_points (list of gps positions with their metadata), raw_points (coordinates only),
	points_tree is the KDTree structure to enable searching the points space
	"""
	data_points = list()
	raw_points = list()

	with open(fname, 'r') as f:
		f.readline()
		for line in f:
			if len(line) < 10:
				continue
			vehicule_id, timestamp, lat, lon, speed, angle = line.split(',')
			pt = GpsPoint(vehicule_id=vehicule_id, timestamp=timestamp, lat=lat, lon=lon, speed=speed,angle=angle)
			data_points.append(pt)
			raw_points.append(pt.get_coordinates())
	points_tree = cKDTree(raw_points)
	return np.array(data_points), np.array(raw_points), points_tree


def create_trajectories(INPUT_FILE_NAME='data/gps_data/gps_points_07-11.csv', waiting_threshold=5):
	"""
	return all trajectories.
	The heuristic is simple. Consider each users sorted traces not broken by more than 1 hour as trajectories.
	:param waiting_threshold: threshold for trajectory split expressed in seconds.
	:return: list of lists of trajectories
	"""

	data_points, raw_points, points_tree = load_data(fname=INPUT_FILE_NAME)
	detections = defaultdict(list)
	for p in data_points:
		detections[p.vehicule_id].append(p)

	# compute trajectories: split detections by waiting_threshold
	print 'Computing trajectories'
	trajectories = []
	for btd, ldetections in detections.iteritems():
		points = sorted(ldetections, key=operator.attrgetter('timestamp'))
		source = 0
		prev_point = 0
		i = 1
		while i < len(points):
			delta = points[i].timestamp - points[prev_point].timestamp
			if delta.days * 24 * 3600 + delta.seconds > waiting_threshold:
				trajectories.append(points[source: i])
				source = i
			prev_point = i
			i += 1
		if source < len(points):
			trajectories.append(points[source: -1])
	return trajectories


def diffangles(a1, a2):
	"""
	Difference between two angles in 0-360 degrees.
	:param a1: angle 1
	:param a2: angle 2
	:return: difference
	"""
	return 180 - abs(abs(a1 - a2) - 180)


def partition_edge(edge, distance_interval):
	"""
	given an edge, creates holes every x meters (distance_interval)
	:param edge: a given edge
	:param distance_interval: in meters
	:return: list of holes
	"""

	# We always return the source node of the edge, hopefully the target will be added as the source of another edge.
	holes = []
	d = geopy.distance.VincentyDistance(meters=distance_interval)
	# make sure we are using lat,lon not lon,lat as a reference.
	startpoint = geopy.Point(edge[0].get_coordinates())
	endpoint = geopy.Point(edge[1].get_coordinates())
	initial_dist = geopy.distance.distance(startpoint, endpoint).meters
	if initial_dist < distance_interval:
		# return [], distance_interval - initial_dist
		return holes
	# compute the angle=bearing at which we need to be moving.
	bearing = calculate_bearing(startpoint[0], startpoint[1], endpoint[0], endpoint[1])
	last_point = startpoint
	diff_time = edge[1].last_seen - edge[0].last_seen
	delta_time = diff_time.days*24*3600 + diff_time.seconds
	time_increment = delta_time / (int(initial_dist) / distance_interval)
	for i in range(int(initial_dist) / distance_interval):
		new_point = geopy.Point(d.destination(point=last_point, bearing=bearing))
		str_timestamp = datetime.datetime.strftime(edge[0].last_seen + datetime.timedelta(seconds=time_increment), "%Y-%m-%d %H:%M:%S+03")
		holes.append(GpsPoint(lat=new_point.latitude, lon=new_point.longitude, angle=bearing,
		                      timestamp=str_timestamp))
		last_point = new_point
	# return holes, initial_dist - (initial_dist / distance_interval) * distance_interval
	return holes


def calculate_bearing(latitude_1, longitude_1, latitude_2, longitude_2):
	"""
	Got it from this link: http://pastebin.com/JbhWKJ5m
   Calculation of direction between two geographical points
   """
	rlat1 = math.radians(latitude_1)
	rlat2 = math.radians(latitude_2)
	rlon1 = math.radians(longitude_1)
	rlon2 = math.radians(longitude_2)
	drlon = rlon2 - rlon1

	b = math.atan2(math.sin(drlon) * math.cos(rlat2), math.cos(rlat1) * math.sin(rlat2) -
	               math.sin(rlat1) * math.cos(rlat2) * math.cos(drlon))
	return (math.degrees(b) + 360) % 360


def vector_direction_re_north(s, d):
	"""
	Make the source as the reference of the plan. Then compute atan2 of the resulting destination point
	:param s: source point
	:param d: destination point
	:return: angle!
	"""

	# find the new coordinates of the destination point in a plan originated at source.
	new_d_lon = d.lon - s.lon
	new_d_lat = d.lat - s.lat
	angle = -math.degrees(math.atan2(new_d_lat, new_d_lon)) + 90

	# the following is required to move the degrees from -180, 180 to 0, 360
	if angle < 0:
		angle = angle + 360
	return angle

def build_roadnet_from_edges(edge_fname='cao_edges.txt'):
	with open(edge_fname, 'r') as f:
		lines = [line for line in f]

	# build directed graph
	g = nx.DiGraph()
	for i in range(len(lines) / 3):
		edge_lines = lines[3 * i: 3 * (i + 1)]
		source = tuple([float(_) for _ in edge_lines[0].strip().split(',')])
		target = tuple([float(_) for _ in edge_lines[1].strip().split(',')[:2]])
		g.add_edge(source, target)
	return g

def draw_network(fname):
	g = build_roadnet_from_edges(fname)
	lines = [[s, t] for s, t in g.edges()]
	lc = mc.LineCollection(lines)
	fig, ax = plt.subplots()
	ax.add_collection(lc)
	ax.autoscale()
	ax.margins(0.1)
	#
	# for s, t in kdd_rn.edges():
	# 	plt.plot([s[0], t[0]], [s[1], t[1]], color='red')
	plt.show()
